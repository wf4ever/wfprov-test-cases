'''
Created on Sep 14, 2012

@author: zhaoj
'''
import os, os.path
import sys
import re
import unittest
import logging
import httplib
import urllib
try:
    # Running Python 2.5 with simplejson?
    import simplejson as json
except ImportError:
    import json
    
# Add main library directory to python path
sys.path.append("../../../..")
sys.path.append("..")

from MiscLib import TestUtils

from SparqlQueryTestCase import SparqlQueryTestCase


class TestEntityOrdering(SparqlQueryTestCase):
    
    def setUp(self):
        super(TestEntityOrdering, self).setUp()
        return

    def tearDown(self):
        super(TestEntityOrdering, self).tearDown()
        return

    #### constraint 38
    
    def testGenerationPrecedesInvalidation(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
            SELECT distinct ?genearated ?invalid
            WHERE {
                ?entity    prov:invalidatedAtTime ?invalid .
                ?entity   prov:generatedAtTime ?generated . 
                filter (?generated > ?invalid)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "Invalidation of entity should be after its generation.")
        
    #### constraint 39
    
    def testGenerationPrecedesUsage(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
            SELECT distinct ?genearated ?used
            WHERE {
                ?entity   prov:generatedAtTime ?generated . 
                ?entity    prov:qualifiedUsage[
                    rdf:type    prov:Usage ;
                    prov:atTime    ?used
                ]                   
                filter (?generated > ?used)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "Usage of entity should be after its generation.")
        
    #### constraint 40
    
    def testUsagePrecedesInvalidation(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
            SELECT distinct ?invalid ?used
            WHERE {
                ?entity   prov:invalidatedAtTime ?invalid . 
                ?entity    prov:qualifiedUsage[
                    rdf:type    prov:Usage ;
                    prov:atTime    ?used
                ]   
                filter (?used > ?invalid)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "Usage of entity should be before its invalidation.")
    
    #### constraint 41

    def testGenerationOrdering(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
            SELECT distinct ?x ?y
            WHERE {
                ?entity   prov:generatedAtTime ?x .
                ?entity   prov:generatedAtTime ?y . 
                filter (?x != ?y)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "An entity cannot be generated by two non-simultaneous events.")
        
    #### constraint 42

    def testInvalidationOrdering(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
            SELECT distinct ?x ?y
            WHERE {
                ?entity   prov:invalidatedAtTime ?x .
                ?entity   prov:invalidatedAtTime ?y . 
                filter (?x != ?y)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "An entity cannot be invalidated by two non-simultaneous events.")

    #### constraint 43
    
    def testDerivationUsageGenerationOrdering(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>  
            SELECT distinct ?usedTime ?generationTime
            WHERE {
                ?entity    prov:wasDerivedFrom    ?usedEntity ;
                           prov:wasGeneratedBy    ?generation ;
                           prov:generatedAtTime    ?generationTime .
                ?generation    prov:qualifiedUsage [
                    rdf:type    prov:Usage ;
                    prov:atTime    ?usedTime ;
                    prov:entity    ?usedEntity ;
                ] 
                filter (?usedTime > ?generationTime)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "An entity should be generated after its derivation used the source entity.")
    
    #### constraint 44

    def testDerivationGenerationGenerationOrdering(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>  
            SELECT distinct ?x ?y
            WHERE {
                ?entity    prov:wasDerivedFrom    ?usedEntity ;
                           prov:wasGeneratedBy    ?generation ;
                           prov:generatedAtTime    ?x .
                ?usedEntity    prov:generatedAtTime    ?y
                filter (?x >= ?y)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "The source entity should be generated before its derived entity.")
    
     #### constraint 45
    def testWasStartedByOrdering(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>  
            SELECT distinct ?x ?y
            WHERE {
                ?entity    prov:generatedAtTime    ?x ;
                           prov:invalidatedAtTime    ?z .
                ?activity    prov:qualifiedStart [
                        rdf:type    prov:Start ;
                        prov:entity    ?entity ;
                        prov:atTime    ?y 
                ]            
                filter (?x > ?y && ?z > ?y)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "The trigger entity should be generated before.")
        
    #### constraint 46
    def testWasEndedByOrdering(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>  
            SELECT distinct ?x ?y
            WHERE {
                ?entity    prov:generatedAtTime    ?x ;
                           prov:invalidatedAtTime    ?z .
                ?activity    prov:qualifiedEnd [
                        rdf:type    prov:End ;
                        prov:entity    ?entity ;
                        prov:atTime    ?y 
                ]            
                filter (?x > ?y && ?z > ?y)
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "The trigger entity should be generated before.")
        
    #### constraint 47
    def testSpecializationGenerationOrdering(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>  
            SELECT distinct ?x ?y
            WHERE {
                ?e1    prov:specializationOf    ?e2 .
                ?e1    prov:generatedAtTime    ?x .
                ?e2    prov:generatedAtTime    ?y .                            
                filter (?x > ?y )
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "The trigger entity should be generated before.")
        
    #### constraint 48
    def testSpecializationInvalidationOrdering(self):
        sparqlquery  = """
            PREFIX prov: <http://www.w3.org/ns/prov#>
            prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>  
            SELECT distinct ?x ?y
            WHERE {
                ?e1    prov:specializationOf    ?e2 .
                ?e1    prov:invalidatedAtTime    ?x .
                ?e2    prov:invalidatedAtTime    ?y .                            
                filter (?x > ?y )
            }
            """
        data = self.doQueryPOST(sparqlquery, JSON=True)
        self.assertBindingEqual(data, 0, "The trigger entity should be generated before.")                        
     
def getTestSuite(select="unit"):
    """
    Get test suite

    select  is one of the following:
            "unit"      return suite of unit tests only
            "component" return suite of unit and component tests
            "all"       return suite of unit, component and integration tests
            "pending"   return suite of pending tests
            name        a single named test to be run
    """
    testdict = {
        "unit":
            [ 
             "testGenerationPrecedesInvalidation",
             "testGenerationPrecedesUsage",
             "testUsagePrecedesInvalidation",
             "testGenerationOrdering",
             "testInvalidationOrdering",
             "testDerivationUsageGenerationOrdering",
             "testDerivationGenerationGenerationOrdering",
             "testWasStartedByOrdering",
             "testWasEndedByOrdering",
             "testSpecializationGenerationOrdering",
             "testSpecializationInvalidationOrdering"
            ],
        }
    return TestUtils.getTestSuite(TestEntityOrdering, testdict, select=select)

if __name__ == "__main__":
    TestUtils.runTests("TestEntityOrdering", getTestSuite, sys.argv)

# End.
